homework_2 :: task_3
reference

1. reference הוא הבאת שם שני למשתנה, ובכך מאפשר לקרוא ולכתוב לאותו מקום בזיכרון שבו הוגדר המשתנה המקורי ולשנות את ערכיו, גם מפונקציות וקבצים אחרים.
הגדרת reference למשתנה מתבצעת על ידי הוספת ampersand (&) אחרי שם הטיפוס. לדוגמה:
int & num2 = num1;
כך הגדרנו את num2 להיות reference ל-num1. כעת, במידה ואשנה את ערכו של num2, הדבר ישנה ישירות את ערכו של num1 בהתאם. הגדרנו שם נוסף למשתנה num1.

2. שני יתרונות בהעברת משתנים לפונקציה by reference על פני שיטות אחרות:
- המשתנה אותו מעבירים לפונקציה לא צריך להיות מועתק, הוא מועבר לפונקציה ללא כל פעולה מיוחדת.
- ניתן להשתמש ב-const reference ובכך להבטיח בקלות כי ערכיו של המשתנה אותו מעבירים לפונקציה לא ישתנו.

3. עבור pointer במרבית המקרים, נצטרך לבדוק קודם כל במהלך הקוד האם הם שונים מ-nullptr. על מנת להימנע משגיאות כמו אי הקצאת זיכרון וכדומה. לכן, שימוש ב-reference נחשב לבטוח יותר שכן אינו יכול להצביע ל-null. בקוד, שימוש ב-reference נעשה בדיוק אותו דבר כמו שימוש במשתנה רגיל, ולכן בהכרח תמיד יהיה זמין ומאותחל. בכך מאפשר לנו כתיבת קוד בטוחה יותר.

4.
א.square(3,y)- תקין, התוצאה מהפונקציה square תישמר במשתנה y.
ב.square(3, &y)- לא תקין, הפונקציה מקבלת מספר שלם ו-reference למשתנה, אנחנו צריכים לשלוח את המשתנה בצורה רגילה (רק את שמו). בקריאה הנ"ל שלחו לפונקציה את הכתובת של המשתנה y וזה היה מתאים אם הפונקציה הייתה מקבלת pointer, אך היא לא.
ג. square(3,6)- לא תקין. הפונקציה square צריכה בפרמטר השני שלה לקבל reference למשתנה, ולא מספר חיובי.

5.a. הפונקציה getLocalVar מחזירה reference למשתנה מקומי שהוקצה עבורו מקום בstack בזיכרון. כאשר הפונקציה מגיעה ל-return מתבצע שחרור של כל המשתנים המקומיים שהוקצה עבורם מקום במחסנית במהלך הפונקציה. לכן, הדבר לא אפשרי מאחר ואנחנו נחזיר reference למשהו שאינו קיים עוד. על כן יגרום לשגיאה.

b. הפונקציה getDynamicVar מחזירה reference למקום שהוקצה עבורו מקום ב-heap בזיכרון (שכן המערך הוקצה בהקצאה דינמית). לאחר שיוצאים מהפונקציה הנ"ל, אין לנו גישה לשאר המקום שהוקצה בזיכרון, על כן- יכול להיווצר מצב של דליפת זיכרון כיוון שלא שחררנו את הזיכרון שהקצאנו בפונקציה.








